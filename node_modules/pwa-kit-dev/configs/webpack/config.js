"use strict";

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireWildcard(require("path"));

var _webpack = _interopRequireDefault(require("webpack"));

var _webpackNotifier = _interopRequireDefault(require("webpack-notifier"));

var _copyWebpackPlugin = _interopRequireDefault(require("copy-webpack-plugin"));

var _webpackBundleAnalyzer = require("webpack-bundle-analyzer");

var _webpackPlugin = _interopRequireDefault(require("@loadable/webpack-plugin"));

var _reactRefreshWebpackPlugin = _interopRequireDefault(require("@pmmmwh/react-refresh-webpack-plugin"));

var _speedMeasureWebpackPlugin = _interopRequireDefault(require("speed-measure-webpack-plugin"));

var _plugins = require("./plugins");

var _configNames = require("./config-names");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const projectDir = process.cwd();
const sdkDir = (0, _path.resolve)(_path.default.join(__dirname, '..', '..', '..'));

const pkg = require((0, _path.resolve)(projectDir, 'package.json'));

const buildDir = process.env.PWA_KIT_BUILD_DIR ? (0, _path.resolve)(process.env.PWA_KIT_BUILD_DIR) : (0, _path.resolve)(projectDir, 'build');
const production = 'production';
const development = 'development';
const analyzeBundle = process.env.MOBIFY_ANALYZE === 'true';
const mode = process.env.NODE_ENV === production ? production : development;
const DEBUG = mode !== production && process.env.DEBUG === 'true';
const CI = process.env.CI;
const disableHMR = process.env.HMR === 'false';

if ([production, development].indexOf(mode) < 0) {
  throw new Error(`Invalid mode "${mode}"`);
}

const getBundleAnalyzerPlugin = (name = 'report', pluginOptions) => new _webpackBundleAnalyzer.BundleAnalyzerPlugin(_objectSpread({
  analyzerMode: 'static',
  defaultSizes: 'gzip',
  openAnalyzer: CI !== 'true',
  generateStatsFile: true,
  reportFilename: `${name}.html`,
  reportTitle: `${name} bundle analysis result`,
  statsFilename: `${name}-analyzer-stats.json`
}, pluginOptions));

const entryPointExists = segments => {
  for (let ext of ['.js', '.jsx', '.ts', '.tsx']) {
    const p = (0, _path.resolve)(projectDir, ...segments) + ext;

    if (_fs.default.existsSync(p)) {
      return true;
    }
  }

  return false;
};

const findInProjectThenSDK = pkg => {
  const projectPath = (0, _path.resolve)(projectDir, 'node_modules', pkg);
  return _fs.default.existsSync(projectPath) ? projectPath : (0, _path.resolve)(sdkDir, 'node_modules', pkg);
};

const baseConfig = target => {
  if (!['web', 'node'].includes(target)) {
    throw Error(`The value "${target}" is not a supported webpack target`);
  }

  class Builder {
    constructor() {
      this.config = _objectSpread(_objectSpread({
        watchOptions: {
          aggregateTimeout: 1000
        },
        target,
        mode
      }, target === 'node' ? {
        ignoreWarnings: [// These can be ignored fairly safely for node targets, where
        // bundle size is not super critical. Express generates this warning,
        // because it uses dynamic require() calls, which cause Webpack to
        // bundle the whole library.
        /Critical dependency: the request of a dependency is an expression/]
      } : {}), {}, {
        infrastructureLogging: {
          level: 'error'
        },
        stats: {
          all: false,
          modules: false,
          errors: true,
          warnings: true,
          moduleTrace: true,
          errorDetails: true,
          colors: true,
          assets: false,
          excludeAssets: [/.*img\/.*/, /.*svg\/.*/, /.*json\/.*/, /.*static\/.*/]
        },
        optimization: {
          minimize: mode === production
        },
        output: {
          publicPath: '',
          path: buildDir
        },
        resolve: _objectSpread({
          extensions: ['.ts', '.tsx', '.js', '.jsx', '.json'],
          alias: {
            'babel-runtime': findInProjectThenSDK('babel-runtime'),
            '@tanstack/react-query': findInProjectThenSDK('@tanstack/react-query'),
            '@loadable/component': findInProjectThenSDK('@loadable/component'),
            '@loadable/server': findInProjectThenSDK('@loadable/server'),
            '@loadable/webpack-plugin': findInProjectThenSDK('@loadable/webpack-plugin'),
            'svg-sprite-loader': findInProjectThenSDK('svg-sprite-loader'),
            react: findInProjectThenSDK('react'),
            'react-router-dom': findInProjectThenSDK('react-router-dom'),
            'react-dom': findInProjectThenSDK('react-dom'),
            'react-helmet': findInProjectThenSDK('react-helmet'),
            'webpack-hot-middleware': findInProjectThenSDK('webpack-hot-middleware')
          }
        }, target === 'web' ? {
          fallback: {
            crypto: false
          }
        } : {}),
        plugins: [new _webpack.default.DefinePlugin({
          DEBUG,
          NODE_ENV: `'${process.env.NODE_ENV}'`,
          WEBPACK_TARGET: `'${target}'`,
          ['global.GENTLY']: false
        }), mode === development && new _webpack.default.NoEmitOnErrorsPlugin(), (0, _plugins.createModuleReplacementPlugin)(projectDir), // Don't chunk if it's a node target – faster Lambda startup.
        target === 'node' && new _webpack.default.optimize.LimitChunkCountPlugin({
          maxChunks: 1
        })].filter(Boolean),
        module: {
          rules: [ruleForBabelLoader(), target === 'node' && {
            test: /\.svg$/,
            loader: findInProjectThenSDK('svg-sprite-loader')
          }, target === 'web' && {
            test: /\.svg$/,
            loader: findInProjectThenSDK('ignore-loader')
          }, {
            test: /\.html$/,
            exclude: /node_modules/,
            use: {
              loader: findInProjectThenSDK('html-loader')
            }
          }].filter(Boolean)
        }
      });
    }

    extend(callback) {
      this.config = callback(this.config);
      return this;
    }

    build() {
      // Clean up temporary properties, to be compatible with the config schema
      this.config.module.rules.filter(rule => rule.id).forEach(rule => delete rule.id);
      return this.config;
    }

  }

  return new Builder();
};

const withChunking = config => {
  return _objectSpread(_objectSpread({}, config), {}, {
    output: _objectSpread(_objectSpread({}, config.output), {}, {
      filename: '[name].js',
      chunkFilename: '[name].js' // Support chunking with @loadable/components

    }),
    optimization: {
      minimize: mode === production,
      splitChunks: {
        cacheGroups: {
          vendor: {
            // Anything imported from node_modules lands in
            // vendor.js, if we're chunking.
            test: /node_modules/,
            name: 'vendor',
            chunks: 'all'
          }
        }
      }
    }
  });
};

const ruleForBabelLoader = babelPlugins => {
  return {
    id: 'babel-loader',
    test: /(\.js(x?)|\.ts(x?))$/,
    exclude: /node_modules/,
    use: [{
      loader: findInProjectThenSDK('babel-loader'),
      options: _objectSpread({
        rootMode: 'upward',
        cacheDirectory: true
      }, babelPlugins ? {
        plugins: babelPlugins
      } : {})
    }]
  };
};

const findAndReplace = (array = [], findFn = () => {}, replacement) => {
  const clone = array.slice(0);
  const index = clone.findIndex(findFn);

  if (index === -1) {
    return array;
  }

  clone.splice(index, 1, replacement);
  return clone;
};

const enableReactRefresh = config => {
  if (mode !== development || disableHMR) {
    return config;
  }

  const newRule = ruleForBabelLoader([require.resolve('react-refresh/babel')]);
  const rules = findAndReplace(config.module.rules, rule => rule.id === 'babel-loader', newRule);
  return _objectSpread(_objectSpread({}, config), {}, {
    module: _objectSpread(_objectSpread({}, config.module), {}, {
      rules
    }),
    entry: _objectSpread(_objectSpread({}, config.entry), {}, {
      main: ['webpack-hot-middleware/client?path=/__mrt/hmr', './app/main']
    }),
    plugins: [...config.plugins, new _webpack.default.HotModuleReplacementPlugin(), new _reactRefreshWebpackPlugin.default({
      overlay: false
    })],
    output: _objectSpread(_objectSpread({}, config.output), {}, {
      // Setting this so that *.hot-update.json requests are resolving
      publicPath: '/mobify/bundle/development/'
    })
  });
};

const client = entryPointExists(['app', 'main']) && baseConfig('web').extend(withChunking).extend(config => {
  return _objectSpread(_objectSpread({}, config), {}, {
    // Must be named "client". See - https://www.npmjs.com/package/webpack-hot-server-middleware#usage
    name: _configNames.CLIENT,
    // use source map to make debugging easier
    devtool: mode === development ? 'source-map' : false,
    entry: {
      main: './app/main'
    },
    plugins: [...config.plugins, new _webpackPlugin.default({
      writeToDisk: true
    }), analyzeBundle && getBundleAnalyzerPlugin(_configNames.CLIENT)].filter(Boolean),
    // Hide the performance hints, since we already have a similar `bundlesize` check in `template-retail-react-app` package
    performance: {
      hints: false
    }
  });
}).extend(enableReactRefresh).build();

const optional = (name, path) => {
  return _fs.default.existsSync(path) ? {
    [name]: path
  } : {};
};

const clientOptional = baseConfig('web').extend(config => {
  return _objectSpread(_objectSpread({}, config), {}, {
    name: _configNames.CLIENT_OPTIONAL,
    entry: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, optional('loader', './app/loader.js')), optional('worker', './worker/main.js')), optional('core-polyfill', (0, _path.resolve)(projectDir, 'node_modules', 'core-js'))), optional('fetch-polyfill', (0, _path.resolve)(projectDir, 'node_modules', 'whatwg-fetch'))),
    // use source map to make debugging easier
    devtool: mode === development ? 'source-map' : false,
    plugins: [...config.plugins, analyzeBundle && getBundleAnalyzerPlugin(_configNames.CLIENT_OPTIONAL)].filter(Boolean)
  });
}).build();
const renderer = _fs.default.existsSync((0, _path.resolve)(projectDir, 'node_modules', 'pwa-kit-react-sdk')) && baseConfig('node').extend(config => {
  return _objectSpread(_objectSpread({}, config), {}, {
    // Must be named "server". See - https://www.npmjs.com/package/webpack-hot-server-middleware#usage
    name: _configNames.SERVER,
    entry: 'pwa-kit-react-sdk/ssr/server/react-rendering.js',
    // use eval-source-map for server-side debugging
    devtool: mode === development ? 'eval-source-map' : false,
    output: {
      path: buildDir,
      filename: 'server-renderer.js',
      libraryTarget: 'commonjs2'
    },
    plugins: [...config.plugins, // Keep this on the slowest-to-build item - the server-side bundle.
    new _webpackNotifier.default({
      title: `PWA Kit Project: ${pkg.name}`,
      excludeWarnings: true,
      skipFirstNotification: true
    }), // Must only appear on one config – this one is the only mandatory one.
    new _copyWebpackPlugin.default({
      patterns: [{
        from: 'app/static/',
        to: 'static/'
      }]
    }), analyzeBundle && getBundleAnalyzerPlugin('server-renderer')].filter(Boolean)
  });
}).build();

const ssr = (() => {
  // Only compile the ssr file when we're building for prod.
  if (mode === production) {
    return baseConfig('node').extend(config => {
      return _objectSpread(_objectSpread({}, config), {}, {
        // Must *not* be named "server". See - https://www.npmjs.com/package/webpack-hot-server-middleware#usage
        name: _configNames.SSR,
        entry: './app/ssr.js',
        output: {
          path: buildDir,
          filename: 'ssr.js',
          libraryTarget: 'commonjs2'
        },
        plugins: [...config.plugins, analyzeBundle && getBundleAnalyzerPlugin(_configNames.SSR)].filter(Boolean)
      });
    }).build();
  } else {
    return undefined;
  }
})();

const requestProcessor = entryPointExists(['app', 'request-processor']) && baseConfig('node').extend(config => {
  return _objectSpread(_objectSpread({}, config), {}, {
    name: _configNames.REQUEST_PROCESSOR,
    entry: './app/request-processor.js',
    output: {
      path: buildDir,
      filename: 'request-processor.js',
      libraryTarget: 'commonjs2'
    },
    // use eval-source-map for server-side debugging
    devtool: mode === development ? 'eval-source-map' : false,
    plugins: [...config.plugins, analyzeBundle && getBundleAnalyzerPlugin(_configNames.REQUEST_PROCESSOR)].filter(Boolean)
  });
}).build();
module.exports = [client, ssr, renderer, clientOptional, requestProcessor].filter(Boolean).map(config => {
  return new _speedMeasureWebpackPlugin.default({
    disable: !process.env.MEASURE
  }).wrap(config);
});